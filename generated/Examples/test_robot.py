"""

The  code  in  file  has  been  generated by NYXX Code Generator on 07/24/2020,
14:26:41. Consider testing this code before using it as errors remain possible.
For  more  details,  check  out  the  github  repository  of  this  projets  at
https://github.com/Teskann/NYXX.

"""

from math import cos, sin
from numpy import array, cross, dot, zeros, eye

# -----------------------------------------------------------------------------
# |                        FORWARD TRANSISION MATRICES                        |
# -----------------------------------------------------------------------------

# Joint 0 _____________________________________________________________________

def T_joint1(theta_joint1):
    """
    Description
    -----------
    
    Transition Matrix to go from link link1 to link link2.
    This joint is continuous. The matrix is :
    
    [1          0                  0           0]
    [                                           ]
    [0  cos(theta_joint1)  -sin(theta_joint1)  0]
    [                                           ]
    [0  sin(theta_joint1)  cos(theta_joint1)   0]
    [                                           ]
    [0          0                  0           1]
    
    Parameters
    ----------
    
    theta_joint1 : float
        Rotation value (in radians) around the joint1 joint axis.
    
    """

    # Returned Matrix
    mat = array([[1,0,0,0],
          [0,cos(theta_joint1),-sin(theta_joint1),0],
          [0,sin(theta_joint1),cos(theta_joint1),0],
          [0,0,0,1]])

    return mat


# Joint 1 _____________________________________________________________________

def T_joint2(theta_joint2):
    """
    Description
    -----------
    
    Transition Matrix to go from link link1 to link link3.
    This joint is continuous. The matrix is :
    
    [1          0                  0           0]
    [                                           ]
    [0  cos(theta_joint2)  -sin(theta_joint2)  0]
    [                                           ]
    [0  sin(theta_joint2)  cos(theta_joint2)   0]
    [                                           ]
    [0          0                  0           1]
    
    Parameters
    ----------
    
    theta_joint2 : float
        Rotation value (in radians) around the joint2 joint axis.
    
    """

    # Returned Matrix
    mat = array([[1,0,0,0],
          [0,cos(theta_joint2),-sin(theta_joint2),0],
          [0,sin(theta_joint2),cos(theta_joint2),0],
          [0,0,0,1]])

    return mat


# Joint 2 _____________________________________________________________________

def T_joint3(theta_joint3):
    """
    Description
    -----------
    
    Transition Matrix to go from link link3 to link link4.
    This joint is continuous. The matrix is :
    
    [1          0                  0           0]
    [                                           ]
    [0  cos(theta_joint3)  -sin(theta_joint3)  0]
    [                                           ]
    [0  sin(theta_joint3)  cos(theta_joint3)   0]
    [                                           ]
    [0          0                  0           1]
    
    Parameters
    ----------
    
    theta_joint3 : float
        Rotation value (in radians) around the joint3 joint axis.
    
    """

    # Returned Matrix
    mat = array([[1,0,0,0],
          [0,cos(theta_joint3),-sin(theta_joint3),0],
          [0,sin(theta_joint3),cos(theta_joint3),0],
          [0,0,0,1]])

    return mat




# -----------------------------------------------------------------------------
# |                            FORWARD KINEMATICS                             |
# -----------------------------------------------------------------------------

# Forward Kinematics from link_0 to link_1 ____________________________________

def fk_link1_link2(q):
    """
    Description
    -----------
    
    Comuputes the forward kinematics from the link link1 to the link link2. The
    result is returned as a 4x4 numpy.ndarray in homogeneous coordinates.
    
    Parameters
    ----------
    
    q : numpy.ndarray
        Vector of variables where :
            - q[0] = theta_joint1 :
                  Rotation value (in radians) around the joint1 joint axis.
    
    """

    T_0 = T_joint1(q[0])
    
    return T_0


# Forward Kinematics from link_0 to link_3 ____________________________________

def fk_link1_link4(q):
    """
    Description
    -----------
    
    Comuputes the forward kinematics from the link link1 to the link link4. The
    result is returned as a 4x4 numpy.ndarray in homogeneous coordinates.
    
    Parameters
    ----------
    
    q : numpy.ndarray
        Vector of variables where :
            - q[0] = theta_joint2 :
                  Rotation value (in radians) around the joint2 joint axis.
            - q[1] = theta_joint3 :
                  Rotation value (in radians) around the joint3 joint axis.
    
    """

    T_1 = T_joint2(q[0])
    T_2 = T_joint3(q[1])
    
    return dot(T_1,T_2)


# -----------------------------------------------------------------------------
# |                                 JACOBIANS                                 |
# -----------------------------------------------------------------------------

# Jacobian of the link_1 position and orientation _____________________________

def jacobian_link1_to_link2(p0, q):
    """
    Description
    -----------
    
    Computes  the  Jacobian  Matrix of the link2 coordinates in the link1 frame
    from  the point p0. This matrix is returned as a (6 x 1) matrix where every
    column  is  the  derivative  of  the position/orientation with respect to a
    degree of freedom.
          -  The  line  1 is the derivative of X position of link2 in the link1
          frame,
          -  The  line  2 is the derivative of Y position of link2 in the link1
          frame,
          -  The  line  3 is the derivative of Z position of link2 in the link1
          frame,
          -  The  line  4 is the derivative of the roll orientation of link2 in
          the link1 frame,
          -  The  line 5 is the derivative of the pitch orientation of link2 in
          the link1 frame,
          - The line 6 is the derivative of the yaw orientation of link2 in the
          link1 frame,
    Here is the list of all the derivative variables :
        - Column 0 : theta_joint1
    
    Parameters
    ----------
    
    p0 : numpy.ndarray
        Point in the link1 frame where you want to compute the Jacobian Matrix.
        p0 is a (3 x 1) vector.
    
    q : numpy.ndarray
        Vector  of  length 1 containing all the degrees of freedom of the robot
        between link1 and link2 chain. This vector contains :
            - q[0] = theta_joint1 :
                  Rotation value (in radians) around the joint1 joint axis.
    
    """

    Jac = zeros((6, 1))
    T = T_joint1(q[0])
    L = p0-T[0:3,3]
    Z = T[0:3,2]
    Jac[0:3,0] = cross(Z,L)
    Jac[3:6,0] = Z
    
    return Jac


# Jacobian of the link_3 position and orientation _____________________________

def jacobian_link1_to_link4(p0, q):
    """
    Description
    -----------
    
    Computes  the  Jacobian  Matrix of the link4 coordinates in the link1 frame
    from  the point p0. This matrix is returned as a (6 x 2) matrix where every
    column  is  the  derivative  of  the position/orientation with respect to a
    degree of freedom.
          -  The  line  1 is the derivative of X position of link4 in the link1
          frame,
          -  The  line  2 is the derivative of Y position of link4 in the link1
          frame,
          -  The  line  3 is the derivative of Z position of link4 in the link1
          frame,
          -  The  line  4 is the derivative of the roll orientation of link4 in
          the link1 frame,
          -  The  line 5 is the derivative of the pitch orientation of link4 in
          the link1 frame,
          - The line 6 is the derivative of the yaw orientation of link4 in the
          link1 frame,
    Here is the list of all the derivative variables :
        - Column 0 : theta_joint2
        - Column 1 : theta_joint3
    
    Parameters
    ----------
    
    p0 : numpy.ndarray
        Point in the link1 frame where you want to compute the Jacobian Matrix.
        p0 is a (3 x 1) vector.
    
    q : numpy.ndarray
        Vector  of  length 2 containing all the degrees of freedom of the robot
        between link1 and link4 chain. This vector contains :
            - q[0] = theta_joint2 :
                  Rotation value (in radians) around the joint2 joint axis.
            - q[1] = theta_joint3 :
                  Rotation value (in radians) around the joint3 joint axis.
    
    """

    Jac = zeros((6, 2))
    T = T_joint2(q[0])
    L = p0-T[0:3,3]
    Z = T[0:3,2]
    Jac[0:3,0] = cross(Z,L)
    Jac[3:6,0] = Z
    T = dot(T,T_joint3(q[1]))
    L = p0-T[0:3,3]
    Z = T[0:3,2]
    Jac[0:3,1] = cross(Z,L)
    Jac[3:6,1] = Z
    
    return Jac


# Center of mass function can not be generated because the robot mass is null.

# Center of mass jacobian function can not be generated because the robot mass is null.
