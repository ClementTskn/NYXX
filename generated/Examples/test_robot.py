"""

The  code  in  file has been generated by URDFast Code Generator on 10/18/2020,
17:57:38. Consider testing this code before using it as errors remain possible.
For  more  details,  check  out  the  github  repository  of  this  projets  at
https://github.com/Teskann/URDFast.

"""

from math import cos, sin
from numpy import array, cross, dot, zeros, eye

# -----------------------------------------------------------------------------
# |                        FORWARD TRANSISION MATRICES                        |
# -----------------------------------------------------------------------------

# Joint 0 _____________________________________________________________________

def T_joint1(theta_joint1):
    """
    Description
    -----------
    
    Transition Matrix to go from link link1 to link link2.
    This joint is continuous. The matrix is :
    
    [    -0.5*cos(theta_joint1) - 0.5          0.5*cos(theta_joint1) - 0.5   
    [                                                                        
    [    0.5*cos(theta_joint1) - 0.5          -0.5*cos(theta_joint1) - 0.5   
    [                                                                        
    [-0.707106781186547*sin(theta_joint1)  0.707106781186547*sin(theta_joint1
    [                                                                        
    [                 0                                     0                
    
       -0.707106781186694*sin(theta_joint1)  0]
                                              ]
       0.707106781186401*sin(theta_joint1)   1]
                                              ]
    )           cos(theta_joint1)            0]
                                              ]
                        0                    1]
    
    Parameters
    ----------
    
    theta_joint1 : float
        Rotation value (in radians) around the joint1 joint axis.
    
    """

    v_sin = sin(theta_joint1)
    v_cos = cos(theta_joint1)
    v_negative = -0.5
    v_prod = 0.5*v_cos
    v_prod_0 = v_negative*v_cos
    v_sub = v_prod_0-0.5
    v_sub_0 = v_prod-0.5
    
    # Returned Matrix
    mat = array([[v_sub,v_sub_0,-0.707106781186694*v_sin,0],
          [v_sub_0,v_sub,0.707106781186401*v_sin,1],
          [-0.707106781186547*v_sin,0.707106781186547*v_sin,v_cos,0],
          [0,0,0,1]])

    return mat


# Joint 1 _____________________________________________________________________

def T_joint2(theta_joint2):
    """
    Description
    -----------
    
    Transition Matrix to go from link link1 to link link3.
    This joint is continuous. The matrix is :
    
    [1          0                  0           0]
    [                                           ]
    [0  cos(theta_joint2)  -sin(theta_joint2)  0]
    [                                           ]
    [0  sin(theta_joint2)  cos(theta_joint2)   0]
    [                                           ]
    [0          0                  0           1]
    
    Parameters
    ----------
    
    theta_joint2 : float
        Rotation value (in radians) around the joint2 joint axis.
    
    """

    v_sin = sin(theta_joint2)
    v_cos = cos(theta_joint2)
    
    # Returned Matrix
    mat = array([[1,0,0,0],
          [0,v_cos,-v_sin,0],
          [0,v_sin,v_cos,0],
          [0,0,0,1]])

    return mat


# Joint 2 _____________________________________________________________________

def T_joint3(theta_joint3):
    """
    Description
    -----------
    
    Transition Matrix to go from link link3 to link link4.
    This joint is continuous. The matrix is :
    
    [1          0                  0           0]
    [                                           ]
    [0  cos(theta_joint3)  -sin(theta_joint3)  0]
    [                                           ]
    [0  sin(theta_joint3)  cos(theta_joint3)   0]
    [                                           ]
    [0          0                  0           1]
    
    Parameters
    ----------
    
    theta_joint3 : float
        Rotation value (in radians) around the joint3 joint axis.
    
    """

    v_sin = sin(theta_joint3)
    v_cos = cos(theta_joint3)
    
    # Returned Matrix
    mat = array([[1,0,0,0],
          [0,v_cos,-v_sin,0],
          [0,v_sin,v_cos,0],
          [0,0,0,1]])

    return mat


# -----------------------------------------------------------------------------
# |                       BACKWARD TRANSISION MATRICES                        |
# -----------------------------------------------------------------------------

# Joint 0 Inverse _____________________________________________________________

def T_joint1_inv(theta_joint1):
    """
    Description
    -----------
    
    Transition Matrix to go from link link2 to link link1.
    This joint is continuous. The matrix is :
    
    [         2                          3                                   
    [0.375*sin (theta_joint1) - 0.125*cos (theta_joint1) - 0.375*cos(theta_jo
    [------------------------------------------------------------------------
    [                        2                                               
    [              - 0.25*sin (theta_joint1) + 0.5*cos(theta_joint1) + 0.5   
    [                                                                        
    [                                     2                                  
    [                             -0.5*sin (theta_joint1)                    
    [                             ------------------------                   
    [                             cos(theta_joint1) + 1.0                    
    [                                                                        
    [                       -0.707106781186547*sin(theta_joint1)             
    [                                                                        
    [                                         0                              
    
                                                      /                    2 
    int1) - 0.5                                       \0.17677669529671*sin (
    -----------      0.5*cos(theta_joint1) - 0.5      -----------------------
                                                                             
                                                                             
                                                                             
                                                                             
                                                                      2.0*(0.
                    -0.5*cos(theta_joint1) - 0.5                      -------
                                                                             
                                                                             
                 0.707106781186547*sin(theta_joint1)                         
                                                                             
                                  0                                          
    
                                                                          \  
    theta_joint1) - 0.35355339059331*cos(theta_joint1) - 0.353553390593347/*s
    -------------------------------------------------------------------------
                   2                                                         
         - 0.25*sin (theta_joint1) + 0.5*cos(theta_joint1) + 0.5             
                                                                             
                                                                             
    353553390593201*cos(theta_joint1) + 0.353553390593274)*sin(theta_joint1) 
    ------------------------------------------------------------------------ 
                         cos(theta_joint1) + 1.0                             
                                                                             
                            cos(theta_joint1)                                
                                                                             
                                    0                                        
    
                                                          ]
    in(theta_joint1)                                      ]
    ----------------      0.5 - 0.5*cos(theta_joint1)     ]
                                                          ]
                                                          ]
                                                          ]
                                                          ]
                                                          ]
                          0.5*cos(theta_joint1) + 0.5     ]
                                                          ]
                                                          ]
                      -0.707106781186547*sin(theta_joint1)]
                                                          ]
                                      1.0                 ]
    
    
    Parameters
    ----------
    
    theta_joint1 : float
        Rotation value (in radians) around the joint1 joint axis.
    
    """

    v_sin = sin(theta_joint1)
    v_cos = cos(theta_joint1)
    v_negative = -0.707106781186547
    v_negative_0 = -0.25
    v_negative_1 = -0.5
    v_sum = v_cos+1.0
    v_prod = 0.5*v_cos
    v_prod_0 = v_negative*v_sin
    v_exp = v_sin**2
    v_prod_1 = v_negative_0*v_exp
    v_sum_0 = v_prod_1+v_prod+0.5
    
    # Returned Matrix
    mat = array([[(((0.375*v_exp-0.125*v_cos**3)-0.375*v_cos)-0.5)/v_sum_0,v_prod-0.5,((0.17677669529671*v_exp-0.35355339059331*v_cos)-0.353553390593347)*v_sin/v_sum_0,0.5-v_prod],
          [v_negative_1*v_exp/v_sum,v_negative_1*v_cos-0.5,2.0*(0.353553390593201*v_cos+0.353553390593274)*v_sin/v_sum,v_prod+0.5],
          [v_prod_0,0.707106781186547*v_sin,v_cos,v_prod_0],
          [0,0,0,1.00000000000000]])

    return mat


# Joint 1 Inverse _____________________________________________________________

def T_joint2_inv(theta_joint2):
    """
    Description
    -----------
    
    Transition Matrix to go from link link3 to link link1.
    This joint is continuous. The matrix is :
    
    [1.0          0                   0           0 ]
    [                                               ]
    [ 0   cos(theta_joint2)   sin(theta_joint2)   0 ]
    [                                               ]
    [ 0   -sin(theta_joint2)  cos(theta_joint2)   0 ]
    [                                               ]
    [ 0           0                   0          1.0]
    
    
    Parameters
    ----------
    
    theta_joint2 : float
        Rotation value (in radians) around the joint2 joint axis.
    
    """

    v_sin = sin(theta_joint2)
    v_cos = cos(theta_joint2)
    
    # Returned Matrix
    mat = array([[1.00000000000000,0,0,0],
          [0,v_cos,v_sin,0],
          [0,-v_sin,v_cos,0],
          [0,0,0,1.00000000000000]])

    return mat


# Joint 2 Inverse _____________________________________________________________

def T_joint3_inv(theta_joint3):
    """
    Description
    -----------
    
    Transition Matrix to go from link link4 to link link3.
    This joint is continuous. The matrix is :
    
    [1.0          0                   0           0 ]
    [                                               ]
    [ 0   cos(theta_joint3)   sin(theta_joint3)   0 ]
    [                                               ]
    [ 0   -sin(theta_joint3)  cos(theta_joint3)   0 ]
    [                                               ]
    [ 0           0                   0          1.0]
    
    
    Parameters
    ----------
    
    theta_joint3 : float
        Rotation value (in radians) around the joint3 joint axis.
    
    """

    v_sin = sin(theta_joint3)
    v_cos = cos(theta_joint3)
    
    # Returned Matrix
    mat = array([[1.00000000000000,0,0,0],
          [0,v_cos,v_sin,0],
          [0,-v_sin,v_cos,0],
          [0,0,0,1.00000000000000]])

    return mat


# -----------------------------------------------------------------------------
# |                            FORWARD KINEMATICS                             |
# -----------------------------------------------------------------------------

# Forward Kinematics from link_0 to link_1 ____________________________________

def fk_link1_link2(q):
    """
    Description
    -----------
    
    Comuputes the forward kinematics from the link link1 to the link link2. The
    result is returned as a 4x4 numpy.ndarray in homogeneous coordinates.
    
    Parameters
    ----------
    
    q : numpy.ndarray
        Vector of variables where :
            - q[0] = theta_joint1 :
                  Rotation value (in radians) around the joint1 joint axis.
    
    """

    T_0 = T_joint1(q[0])
    
    return T_0


# Forward Kinematics from link_0 to link_3 ____________________________________

def fk_link1_link4(q):
    """
    Description
    -----------
    
    Comuputes the forward kinematics from the link link1 to the link link4. The
    result is returned as a 4x4 numpy.ndarray in homogeneous coordinates.
    
    Parameters
    ----------
    
    q : numpy.ndarray
        Vector of variables where :
            - q[0] = theta_joint2 :
                  Rotation value (in radians) around the joint2 joint axis.
            - q[1] = theta_joint3 :
                  Rotation value (in radians) around the joint3 joint axis.
    
    """

    T_1 = T_joint2(q[0])
    T_2 = T_joint3(q[1])
    
    return dot(T_1,T_2)


# -----------------------------------------------------------------------------
# |                                 JACOBIANS                                 |
# -----------------------------------------------------------------------------

# Jacobian of the link_1 position and orientation _____________________________

def jacobian_link1_to_link2(p0, q):
    """
    Description
    -----------
    
    Computes  the  Jacobian  Matrix of the link2 coordinates in the link1 frame
    from  the point p0. This matrix is returned as a (6 x 1) matrix where every
    column  is  the  derivative  of  the position/orientation with respect to a
    degree of freedom.
          -  The  line  1 is the derivative of X position of link2 in the link1
          frame,
          -  The  line  2 is the derivative of Y position of link2 in the link1
          frame,
          -  The  line  3 is the derivative of Z position of link2 in the link1
          frame,
          -  The  line  4 is the derivative of the roll orientation of link2 in
          the link1 frame,
          -  The  line 5 is the derivative of the pitch orientation of link2 in
          the link1 frame,
          - The line 6 is the derivative of the yaw orientation of link2 in the
          link1 frame,
    Here is the list of all the derivative variables :
        - Column 0 : theta_joint1
    
    Parameters
    ----------
    
    p0 : numpy.ndarray
        Point in the link1 frame where you want to compute the Jacobian Matrix.
        p0 is a (3 x 1) vector.
    
    q : numpy.ndarray
        Vector  of  length 1 containing all the degrees of freedom of the robot
        between link1 and link2 chain. This vector contains :
            - q[0] = theta_joint1 :
                  Rotation value (in radians) around the joint1 joint axis.
    
    """

    Jac = zeros((6, 1))
    T = T_joint1(q[0])
    L = p0-T[0:3,3]
    Z = T[0:3,2]
    Jac[0:3,0] = cross(Z,L)
    Jac[3:6,0] = Z
    
    return Jac


# Jacobian of the link_3 position and orientation _____________________________

def jacobian_link1_to_link4(p0, q):
    """
    Description
    -----------
    
    Computes  the  Jacobian  Matrix of the link4 coordinates in the link1 frame
    from  the point p0. This matrix is returned as a (6 x 2) matrix where every
    column  is  the  derivative  of  the position/orientation with respect to a
    degree of freedom.
          -  The  line  1 is the derivative of X position of link4 in the link1
          frame,
          -  The  line  2 is the derivative of Y position of link4 in the link1
          frame,
          -  The  line  3 is the derivative of Z position of link4 in the link1
          frame,
          -  The  line  4 is the derivative of the roll orientation of link4 in
          the link1 frame,
          -  The  line 5 is the derivative of the pitch orientation of link4 in
          the link1 frame,
          - The line 6 is the derivative of the yaw orientation of link4 in the
          link1 frame,
    Here is the list of all the derivative variables :
        - Column 0 : theta_joint2
        - Column 1 : theta_joint3
    
    Parameters
    ----------
    
    p0 : numpy.ndarray
        Point in the link1 frame where you want to compute the Jacobian Matrix.
        p0 is a (3 x 1) vector.
    
    q : numpy.ndarray
        Vector  of  length 2 containing all the degrees of freedom of the robot
        between link1 and link4 chain. This vector contains :
            - q[0] = theta_joint2 :
                  Rotation value (in radians) around the joint2 joint axis.
            - q[1] = theta_joint3 :
                  Rotation value (in radians) around the joint3 joint axis.
    
    """

    Jac = zeros((6, 2))
    T = T_joint2(q[0])
    L = p0-T[0:3,3]
    Z = T[0:3,2]
    Jac[0:3,0] = cross(Z,L)
    Jac[3:6,0] = Z
    T = dot(T,T_joint3(q[1]))
    L = p0-T[0:3,3]
    Z = T[0:3,2]
    Jac[0:3,1] = cross(Z,L)
    Jac[3:6,1] = Z
    
    return Jac


# -----------------------------------------------------------------------------
# |                        CENTER OF MASS OF THE ROBOT                        |
# -----------------------------------------------------------------------------

def com(q):
    """
    Description
    -----------
    
    Returns  the center of mass of the robot in the root link frame. The center
    of  mass of the whole structure is computed. The result is returned as a (4
    x  1) numpy.ndarray in homogeneous coordinates. The first three coordinates
    represent  the  X,  Y  and Z positions of the CoM and the 4th coordinate is
    always equal to 1
    
    Parameters
    ----------
    
    q : numpy.ndarray
        Vector  of  length 3 containing all the degrees of freedom of the robot
        that  have  an  effect  on  the  center  of  mass position. This vector
        contains :
            - q[0] = theta_joint1 :
                  Rotation value (in radians) around the joint1 joint axis.
            - q[1] = theta_joint2 :
                  Rotation value (in radians) around the joint2 joint axis.
            - q[2] = theta_joint3 :
                  Rotation value (in radians) around the joint3 joint axis.
    
    """

    T = eye(4, 4)
    com_0_xyz = array([[1.0],[1.0],[1.0],[1.0]])
    com_0 = dot(0.39215686274509803*T,com_0_xyz)
    T = dot(T,T_joint1(q[0]))
    com_1_xyz = array([[1.0],[0.0],[0.0],[1.0]])
    com_1 = dot(0.19607843137254902*T,com_1_xyz)
    T = dot(T,T_joint2(q[1]))
    com_2_xyz = array([[0.0],[1.0],[0.0],[1.0]])
    com_2 = dot(0.39215686274509803*T,com_2_xyz)
    T = dot(T,T_joint3(q[2]))
    com_3_xyz = array([[1.0],[1.0],[0.0],[1.0]])
    com_3 = dot(0.0196078431372549*T,com_3_xyz)
    
    return com_0+com_1+com_2+com_3


# -----------------------------------------------------------------------------
# |                JACOBIAN OF THE CENTER OF MASS OF THE ROBOT                |
# -----------------------------------------------------------------------------

def jacobian_com(com0, q):
    """
    Description
    -----------
    
    Returns  the  Jacobian  of  the center of mass of the robot. This matrix is
    returned  as  a  (3 x 4) matrix where every column is the derivative of the
    position  of  the CoM (X, Y and Z) with respect to a degree of freedom. The
    result  is expressed in the root link frame. - The line 1 is the derivative
    of X position of the center of mass in the world frame,
          - The line 2 is the derivative of Y position of the center of mass in
          the world frame,
          - The line 3 is the derivative of Z position of the center of mass in
          the world frame,
          -  The line 4 is the derivative of the roll orientation of the center
          of mass in the world frame,
          - The line 5 is the derivative of the pitch orientation of the center
          of mass in the world frame,
          -  The  line 6 is the derivative of the yaw orientation of the center
          of mass in the world frame,
    Here is the list of all the derivative variables :
        - Column 0 : theta_joint1
        - Column 1 : theta_joint2
        - Column 2 : theta_joint3
    
    Parameters
    ----------
    
    com0 : numpy.ndarray
        Point  from  which  you  want  to compute the Jacobian of the center of
        Mass.  This  point is expressed in homogeneous coordinates as a (4 x 1)
        numpy.ndarray.  The  first  three  coordinates represent the X, Y and Z
        positions of the CoM and the 4th coordinate must always be equal to 1
    
    q : numpy.ndarray
        Vector  of  all the degrees of freedom of the robot that have an effect
        on the center of mass position. This vector contains :
            - q[0] = theta_joint1 :
                  Rotation value (in radians) around the joint1 joint axis.
            - q[1] = theta_joint2 :
                  Rotation value (in radians) around the joint2 joint axis.
            - q[2] = theta_joint3 :
                  Rotation value (in radians) around the joint3 joint axis.
    
    """

    Jac = zeros((3, 4))
    T = eye(4, 4)
    com_0_xyz = array([[1.0],[1.0],[1.0],[1.0]])
    com = dot(0.39215686274509803*T,com_0_xyz)
    L = com0[0:3]-com[0:3]
    Z = T[0:3,2]
    Jac[0:3,0] = cross(Z,L)
    T = dot(T,T_joint1(q[0]))
    com_1_xyz = array([[1.0],[0.0],[0.0],[1.0]])
    com = dot(0.19607843137254902*T,com_1_xyz)
    L = com0[0:3]-com[0:3]
    Z = T[0:3,2]
    Jac[0:3,1] = cross(Z,L)
    T = dot(T,T_joint2(q[1]))
    com_2_xyz = array([[0.0],[1.0],[0.0],[1.0]])
    com = dot(0.39215686274509803*T,com_2_xyz)
    L = com0[0:3]-com[0:3]
    Z = T[0:3,2]
    Jac[0:3,2] = cross(Z,L)
    T = dot(T,T_joint3(q[2]))
    com_3_xyz = array([[1.0],[1.0],[0.0],[1.0]])
    com = dot(0.0196078431372549*T,com_3_xyz)
    L = com0[0:3]-com[0:3]
    Z = T[0:3,2]
    Jac[0:3,3] = cross(Z,L)
    
    return Jac

